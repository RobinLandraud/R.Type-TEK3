<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>R-type: ChaiScript Versioning</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">R-type
   </div>
   <div id="projectbrief">Creation of the r-type game with an online version</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ChaiScript Versioning </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ChaiScript tries to follow the <a href="http://semver.org/">Semantic Versioning</a> scheme. This basically means:</p>
<ul>
<li>Major Version Number: API changes / breaking changes</li>
<li>Minor Version Number: New Features</li>
<li>Patch Version Number: Minor changes / enhancements</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Initializing ChaiScript</h1>
<div class="fragment"><div class="line">chaiscript::ChaiScript chai; // loads stdlib from loadable module on file system</div>
<div class="line">chaiscript::ChaiScript chai(chaiscript::Std_Lib::library()); // compiles in stdlib</div>
</div><!-- fragment --><p>Note that ChaiScript cannot be used as a global / static object unless it is being compiled with <code>CHAISCRIPT_NO_THREADS</code>.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Adding Things To The Engine</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Adding a Function / Method / Member</h2>
<h3><a class="anchor" id="autotoc_md4"></a>
General</h3>
<div class="fragment"><div class="line">chai.add(chaiscript::fun(&amp;function_name), &quot;function_name&quot;);</div>
<div class="line">chai.add(chaiscript::fun(&amp;Class::method_name), &quot;method_name&quot;);</div>
<div class="line">chai.add(chaiscript::fun(&amp;Class::member_name), &quot;member_name&quot;);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md5"></a>
Bound Member Functions</h3>
<div class="fragment"><div class="line">chai.add(chaiscript::fun(&amp;Class::method_name, Class_instance_ptr), &quot;method_name&quot;);</div>
<div class="line">chai.add(chaiscript::fun(&amp;Class::member_name, Class_instance_ptr), &quot;member_name&quot;);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md6"></a>
With Overloads</h3>
<h4><a class="anchor" id="autotoc_md7"></a>
Preferred</h4>
<div class="fragment"><div class="line">chai.add(chaiscript::fun&lt;ReturnType (ParamType1, ParamType2)&gt;(&amp;function_with_overloads), &quot;function_name&quot;);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md8"></a>
Alternative</h4>
<div class="fragment"><div class="line">chai.add(chaiscript::fun(std::static_cast&lt;ReturnType (*)(ParamType1, ParamType2)&gt;(&amp;function_with_overloads)), &quot;function_name&quot;);</div>
</div><!-- fragment --><p> This overload technique is also used when exposing base member using derived type</p>
<div class="fragment"><div class="line">struct Base</div>
<div class="line">{</div>
<div class="line">  int data;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct Derived : public Base</div>
<div class="line">{};</div>
<div class="line"> </div>
<div class="line">chai.add(chaiscript::fun(static_cast&lt;int(Derived::*)&gt;(&amp;Derived::data)), &quot;data&quot;);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md9"></a>
Lambda</h3>
<div class="fragment"><div class="line">chai.add(</div>
<div class="line">  chaiscript::fun&lt;std::string (bool)&gt;(</div>
<div class="line">    [](bool type) {</div>
<div class="line">      if (type) { return &quot;x&quot;; }</div>
<div class="line">      else { return &quot;y&quot;; }</div>
<div class="line">    }), &quot;function_name&quot;);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
Constructors</h3>
<div class="fragment"><div class="line">chai.add(chaiscript::constructor&lt;MyType ()&gt;(), &quot;MyType&quot;);</div>
<div class="line">chai.add(chaiscript::constructor&lt;MyType (const MyType &amp;)&gt;(), &quot;MyType&quot;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Adding Types</h2>
<p>It's not strictly necessary to add types, but it helps with many things. Cloning, better errors, etc.</p>
<div class="fragment"><div class="line">chai.add(chaiscript::user_type&lt;MyClass&gt;(), &quot;MyClass&quot;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
Adding Type Conversions</h2>
<p><a class="el" href="../../d4/d05/structUser.html" title="The user.">User</a> defined type conversions are possible, defined in either script or in C++.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
ChaiScript Defined Conversions</h3>
<p>Function objects (including lambdas) can be used to add type conversions from inside of ChaiScript:</p>
<div class="fragment"><div class="line">add_type_conversion(type(&quot;string&quot;), type(&quot;Type_Info&quot;), fun(s) { return type(s); });</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
C++ Defined Conversions</h3>
<p>Invoking a C++ type conversion possible with <code>static_cast</code></p>
<div class="fragment"><div class="line">chai.add(chaiscript::type_conversion&lt;T, bool&gt;());</div>
</div><!-- fragment --><p>Calling a user defined type conversion that takes a lambda</p>
<div class="fragment"><div class="line">chai.add(chaiscript::type_conversion&lt;TestBaseType, Type2&gt;([](const TestBaseType &amp;t_bt) { /* return converted thing */ }));</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md15"></a>
Class Hierarchies</h3>
<p>If you want objects to be convertable between base and derived classes, you must tell ChaiScritp about the relationship.</p>
<div class="fragment"><div class="line">chai.add(chaiscript::base_class&lt;Base, Derived&gt;());</div>
</div><!-- fragment --><p>If you have multiple classes in your inheritance graph, you will probably want to tell ChaiScript about all relationships.</p>
<div class="fragment"><div class="line">chai.add(chaiscript::base_class&lt;Base, Derived&gt;());</div>
<div class="line">chai.add(chaiscript::base_class&lt;Derived, MoreDerived&gt;());</div>
<div class="line">chai.add(chaiscript::base_class&lt;Base, MoreDerived&gt;());</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
Helpers</h3>
<p><a class="el" href="../../d2/d88/classA.html">A</a> helper function exists for strongly typed and ChaiScript <code>Vector</code> function conversion definition:</p>
<div class="fragment"><div class="line">chai.add(chaiscript::vector_conversion&lt;std::vector&lt;int&gt;&gt;());</div>
</div><!-- fragment --><p><a class="el" href="../../d2/d88/classA.html">A</a> helper function also exists for strongly typed and ChaiScript <code>Map</code> function conversion definition:</p>
<div class="fragment"><div class="line">chai.add(chaiscript::map_conversion&lt;std::map&lt;std::string, int&gt;&gt;());</div>
</div><!-- fragment --><p>This allows you to pass a ChaiScript function to a function requiring <code>std::vector&lt;int&gt;</code></p>
<h2><a class="anchor" id="autotoc_md17"></a>
Adding Objects</h2>
<div class="fragment"><div class="line">chai.add(chaiscript::var(somevar), &quot;somevar&quot;); // copied in</div>
<div class="line">chai.add(chaiscript::var(std::ref(somevar), &quot;somevar&quot;); // by reference, shared between C++ and chai</div>
<div class="line">auto shareddouble = std::make_shared&lt;double&gt;(4.3);</div>
<div class="line">chai.add(chaiscript::var(shareddouble), &quot;shareddouble&quot;); // by shared_ptr, shared between c++ and chai</div>
<div class="line">chai.add(chaiscript::const_var(somevar), &quot;somevar&quot;); // copied in and made const</div>
<div class="line">chai.add_global_const(chaiscript::const_var(somevar), &quot;somevar&quot;); // global const. Throws if value is non-const, throws if object exists</div>
<div class="line">chai.add_global(chaiscript::var(somevar), &quot;somevar&quot;); // global non-const, throws if object exists</div>
<div class="line">chai.set_global(chaiscript::var(somevar), &quot;somevar&quot;); // global non-const, overwrites existing object</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
Adding Namespaces</h2>
<p>Namespaces will not be populated until <code>import</code> is called. This saves memory and computing costs if a namespace is not imported into every ChaiScript instance. </p><div class="fragment"><div class="line">chai.register_namespace([](chaiscript::Namespace&amp; math) {</div>
<div class="line">    math[&quot;pi&quot;] = chaiscript::const_var(3.14159);</div>
<div class="line">    math[&quot;sin&quot;] = chaiscript::var(chaiscript::fun([](const double x) { return sin(x); })); },</div>
<div class="line">    &quot;math&quot;);</div>
</div><!-- fragment --><p>Import namespace in ChaiScript </p><div class="fragment"><div class="line">import(&quot;math&quot;)</div>
<div class="line">print(math.pi) // prints 3.14159</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md19"></a>
Using STL</h1>
<p>ChaiScript recognize many types from STL, but you have to add specific instantiation yourself.</p>
<div class="fragment"><div class="line">typedef std::vector&lt;std::pair&lt;int, std::string&gt;&gt; data_list;</div>
<div class="line">data_list my_list{ make_pair(0, &quot;Hello&quot;), make_pair(1, &quot;World&quot;) };</div>
<div class="line">chai.add(chaiscript::bootstrap::standard_library::vector_type&lt;data_list&gt;(&quot;DataList&quot;));</div>
<div class="line">chai.add(chaiscript::bootstrap::standard_library::pair_type&lt;data_list::value_type&gt;(&quot;DataElement&quot;));</div>
<div class="line">chai.add(chaiscript::var(&amp;my_list), &quot;data_list&quot;);</div>
<div class="line">chai.eval(R&quot;_(</div>
<div class="line">    for(var i=0; i&lt;data_list.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">      print(to_string(data_list[i].first) + &quot; &quot; + data_list[i].second)</div>
<div class="line">    }</div>
<div class="line">  )_&quot;);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md20"></a>
Executing Script</h1>
<h2><a class="anchor" id="autotoc_md21"></a>
General</h2>
<div class="fragment"><div class="line">chai.eval(&quot;print(\&quot;Hello World\&quot;)&quot;);</div>
<div class="line">chai.eval(R&quot;(print(&quot;Hello World&quot;))&quot;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md22"></a>
Unboxing Return Values</h2>
<p>Returns values are of the type <code>Boxed_Value</code> which is meant to be opaque to the programmer. Use one of the unboxing methods to access the internal data.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
Prefered</h3>
<div class="fragment"><div class="line">chai.eval&lt;double&gt;(&quot;5.3 + 2.1&quot;); // returns 7.4 as a C++ double</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
Alternative</h3>
<div class="fragment"><div class="line">auto v = chai.eval(&quot;5.3 + 2.1&quot;);</div>
<div class="line">chai.boxed_cast&lt;double&gt;(v); // extracts double value from boxed_value and applies known conversions</div>
<div class="line">chaiscript::boxed_cast&lt;double&gt;(v); // free function version, does not know about conversions</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25"></a>
Converting Between Algebraic Types</h3>
<div class="fragment"><div class="line">chaiscript::Boxed_Number(chai.eval(&quot;5.3 + 2.1&quot;)).get_as&lt;int&gt;(); // works with any number type</div>
<div class="line">// which is equivalent to, but much more automatic than:</div>
<div class="line">static_cast&lt;int&gt;(chai.eval&lt;double&gt;(&quot;5.3+2.1&quot;)); // this version only works if we know that it&#39;s a double</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md26"></a>
Conversion Caveats</h3>
<p>Conversion to <code>std::shared_ptr&lt;T&gt; &amp;</code> is supported for function calls, but if you attempt to keep a reference to a <code>shared_ptr&lt;&gt;</code> you might invoke undefined behavior</p>
<div class="fragment"><div class="line"><span class="comment">// ok this is supported, you can register it with chaiscript engine</span></div>
<div class="line"><span class="keywordtype">void</span> nullify_shared_ptr(std::shared_ptr&lt;int&gt; &amp;t) {</div>
<div class="line">  t = <span class="keyword">nullptr</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// do some stuff and create a chaiscript instance</span></div>
<div class="line">  std::shared_ptr&lt;int&gt; &amp;ptr = chai.eval&lt;std::shared_ptr&lt;int&gt; &amp;&gt;(somevalue);</div>
<div class="line">  <span class="comment">// DO NOT do this. Taking a non-const reference to a shared_ptr is not </span></div>
<div class="line">  <span class="comment">// supported and causes undefined behavior in the chaiscript engine</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md27"></a>
Sharing Values</h2>
<div class="fragment"><div class="line">double &amp;d = chai.eval(&quot;var i = 5.2; i&quot;); // d is now a reference to i in the script</div>
<div class="line">std::shared_ptr&lt;double&gt; d = chai.eval(&quot;var i = 5.2; i&quot;); // same result but reference counted</div>
<div class="line"> </div>
<div class="line">d = 3;</div>
<div class="line">chai.eval(&quot;print(i)&quot;); // prints 3</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28"></a>
Catching Eval Errors</h2>
<div class="fragment"><div class="line">try {</div>
<div class="line">  chai.eval(&quot;2.3 + \&quot;String\&quot;&quot;);</div>
<div class="line">} catch (const chaiscript::exception::eval_error &amp;e) {</div>
<div class="line">  std::cout &lt;&lt; &quot;Error\n&quot; &lt;&lt; e.pretty_print() &lt;&lt; &#39;\n&#39;;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md29"></a>
Catching Errors Thrown From Script</h2>
<div class="fragment"><div class="line">try {</div>
<div class="line">  chai.eval(&quot;throw(runtime_error(\&quot;error\&quot;))&quot;, chaiscript::exception_specification&lt;int, double, float, const std::string &amp;, const std::exception &amp;&gt;());</div>
<div class="line">} catch (const double e) {</div>
<div class="line">} catch (int) {</div>
<div class="line">} catch (float) {</div>
<div class="line">} catch (const std::string &amp;) {</div>
<div class="line">} catch (const std::exception &amp;e) {</div>
<div class="line">  // This is the one what will be called in the specific throw() above</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
Sharing Functions</h2>
<div class="fragment"><div class="line">auto p = chai.eval&lt;std::function&lt;std::string (double)&gt;&gt;(&quot;to_string&quot;); </div>
<div class="line">p(5); // calls chaiscript&#39;s &#39;to_string&#39; function, returning std::string(&quot;5&quot;)</div>
</div><!-- fragment --><p>Note: backtick treats operators as normal functions</p>
<div class="fragment"><div class="line">auto p = chai.eval&lt;std::function&lt;int (int, int)&gt;&gt;(`+`); </div>
<div class="line">p(5, 6); // calls chaiscript&#39;s &#39;+&#39; function, returning 11</div>
</div><!-- fragment --><div class="fragment"><div class="line">auto p = chai.eval&lt;std::function&lt;std::string (int, double)&gt;&gt;(&quot;fun(x,y) { to_string(x) + to_string(y); }&quot;);</div>
<div class="line">p(3,4.2); // evaluates the lambda function, returning the string &quot;34.2&quot; to C++</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md31"></a>
Language Reference</h1>
<h2><a class="anchor" id="autotoc_md32"></a>
Variables</h2>
<div class="fragment"><div class="line">var i; // uninitialized variable, can take any value on first assignment;</div>
<div class="line">auto j; // equiv to var</div>
<div class="line"> </div>
<div class="line">var k = 5; // initialized to 5 (integer)</div>
<div class="line">var l := k; // reference to k</div>
<div class="line">auto &amp;m = k; // reference to k</div>
<div class="line"> </div>
<div class="line">global g = 5; // creates a global variable. If global already exists, it is not re-added</div>
<div class="line">global g = 2; // global &#39;g&#39; now equals 2</div>
<div class="line"> </div>
<div class="line">global g2;</div>
<div class="line">if (g2.is_var_undef()) { g2 = 4; } // only initialize g2 once, if global decl hit more than once</div>
<div class="line"> </div>
<div class="line">GLOBAL g3; // all upper case version also accepted</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
Looping</h2>
<div class="fragment"><div class="line">// c-style for loops</div>
<div class="line">for (var i = 0; i &lt; 100; ++i) { print(i); }</div>
</div><!-- fragment --><div class="fragment"><div class="line">// while</div>
<div class="line">while (some_condition()) { /* do something */ }</div>
</div><!-- fragment --><div class="fragment"><div class="line">// ranged for</div>
<div class="line">for (x : [1,2,3]) { print(i); }</div>
</div><!-- fragment --><p>Each of the loop styles can be broken using the <code>break</code> statement. For example:</p>
<div class="fragment"><div class="line">while (some_condition()) {</div>
<div class="line">  /* do something */</div>
<div class="line">  if (another_condition()) { break; }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md34"></a>
Conditionals</h2>
<div class="fragment"><div class="line">if (expression) { }</div>
</div><!-- fragment --><div class="fragment"><div class="line">// C++17-style init-if blocks</div>
<div class="line">// Value of &#39;statement&#39; is scoped for entire `if` block</div>
<div class="line">if (statement; expression) { }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
Switch Statements</h2>
<div class="fragment"><div class="line">var myvalue = 2</div>
<div class="line">switch (myvalue) {</div>
<div class="line">    case (1) {</div>
<div class="line">        print(&quot;My Value is 1&quot;);</div>
<div class="line">        break;</div>
<div class="line">    }</div>
<div class="line">    case (2) {</div>
<div class="line">        print(&quot;My Value is 2&quot;);</div>
<div class="line">        break;</div>
<div class="line">    }</div>
<div class="line">    default {</div>
<div class="line">        print(&quot;My Value is something else.&quot;;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36"></a>
Built in Types</h2>
<div class="fragment"><div class="line">var v = [1,2,3u,4ll,&quot;16&quot;, `+`]; // creates vector of heterogenous values</div>
<div class="line">var m = [&quot;a&quot;:1, &quot;b&quot;:2]; // map of string:value pairs</div>
</div><!-- fragment --><p>Floating point values default to <code>double</code> type and integers default to <code>int</code> type. All C++ suffixes such as <code>f</code>, <code>ll</code>, <code>u</code> as well as scientific notation are supported</p>
<div class="fragment"><div class="line">1.0 // double</div>
<div class="line">1.0f // float</div>
<div class="line">1.0l // long double</div>
<div class="line">1 // int</div>
<div class="line">1u // unsigned int</div>
<div class="line">1ul // unsigned long</div>
<div class="line">1ull // unsigned long long</div>
</div><!-- fragment --><p>Literals are automatically sized, just as in C++. For example: <code>10000000000</code> is &gt; 32bits and the appropriate type is used to hold it on your platform.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Functions</h2>
<p>Note that any type of ChaiScript function can be passed freely to C++ and automatically converted into an <code>std::function</code> object.</p>
<h3><a class="anchor" id="autotoc_md38"></a>
General</h3>
<div class="fragment"><div class="line">def myfun(x, y) { x + y; } // last statement in body is the return value</div>
<div class="line">def myfun(x, y) { return x + y; } // equiv </div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md39"></a>
Optionally Typed</h3>
<div class="fragment"><div class="line">def myfun(x, int y) { x + y; } // requires y to be an int</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md40"></a>
With Guards</h3>
<div class="fragment"><div class="line">def myfun(x, int y) : y &gt; 5 { x - y; } // only called if y &gt; 5</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md41"></a>
Methods</h3>
<p>Methods and functions are mostly equivalent</p>
<div class="fragment"><div class="line">def string::add(int y) { this + to_string(y); }</div>
<div class="line">def add(string s, int y) { s + to_string(y); } //equiv functionality</div>
<div class="line"> </div>
<div class="line">// calling new function/method</div>
<div class="line">&quot;a&quot;.add(1); // returns a1</div>
<div class="line">add(&quot;a&quot;, 1); // returns a1, either calling syntax works with either def above</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md42"></a>
Lambdas</h3>
<div class="fragment"><div class="line">var l = fun(x) { x * 15; }</div>
<div class="line">l(2) // returns 30</div>
<div class="line"> </div>
<div class="line">var a = 13</div>
<div class="line">var m = fun[a](x) { x * a; } </div>
<div class="line">m(3); // a was captured (by reference), returns 39</div>
<div class="line"> </div>
<div class="line">var n = bind(fun(x,y) { x * y; }, _, 10);</div>
<div class="line">n(2); // returns 20 </div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md43"></a>
ChaiScript Defined Types</h2>
<p>Define a type called "MyType" with one member value "a" and a getter</p>
<h3><a class="anchor" id="autotoc_md44"></a>
Preferred</h3>
<div class="fragment"><div class="line">class MyType {</div>
<div class="line">  var value;</div>
<div class="line">  def MyType() { this.value = &quot;a&quot;; }</div>
<div class="line">  def get_value() { &quot;Value Is: &quot; + this.value; }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md45"></a>
Alternative</h3>
<div class="fragment"><div class="line">attr MyType::value;</div>
<div class="line">def MyType::MyType() { this.value = &quot;a&quot;; }</div>
<div class="line">def MyType::get_value() { &quot;Value Is: &quot; + this.value; }</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md46"></a>
Using</h3>
<div class="fragment"><div class="line">var m = MyType(); // calls constructor</div>
<div class="line">print(m.get_value()); // prints &quot;Value Is: a&quot;</div>
<div class="line">print(get_value(m)); // prints &quot;Value Is: a&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md47"></a>
Dynamic Objects</h2>
<p>All ChaiScript defined types and generic Dynamic_Object support dynamic parameters</p>
<div class="fragment"><div class="line">var o = Dynamic_Object();</div>
<div class="line">o.f = fun(x) { print(x); }</div>
<div class="line">o.f(3); // prints &quot;3&quot;</div>
</div><!-- fragment --><p>Implicit 'this' is allowed:</p>
<div class="fragment"><div class="line">var o = Dynamic_Object();</div>
<div class="line">o.x = 3;</div>
<div class="line">o.f = fun(y) { print(this.x + y); }</div>
<div class="line">o.f(10); // prints 13</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md48"></a>
Namespaces</h2>
<p>Namespaces in ChaiScript are Dynamic Objects with global scope</p>
<div class="fragment"><div class="line">namespace(&quot;math&quot;) // create a new namespace</div>
<div class="line"> </div>
<div class="line">math.square = fun(x) { x * x } // add a function to the &quot;math&quot; namespace</div>
<div class="line">math.sum_squares = fun(x, y) { math.square(x) + math.square(y) }</div>
<div class="line"> </div>
<div class="line">print(math.square(4)) // prints 16</div>
<div class="line">print(math.sum_squares(2, 5)) // prints 29</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md49"></a>
Option Explicit</h3>
<p>If you want to disable dynamic parameter definitions, you can <code>set_explicit</code>.</p>
<div class="fragment"><div class="line">class My_Class {</div>
<div class="line">  def My_Class() {</div>
<div class="line">    this.set_explicit(true);</div>
<div class="line">    this.x = 2; // this would fail with explicit set to true</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md50"></a>
method_missing</h2>
<p><a class="el" href="../../d2/d88/classA.html">A</a> function of the signature <code>method_missing(object, name, param1, param2, param3)</code> will be called if an appropriate method cannot be found</p>
<div class="fragment"><div class="line">def method_missing(int i, string name, Vector v) {</div>
<div class="line">  print(&quot;method_missing(${i}, ${name}), ${v.size()} params&quot;);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">5.bob(1,2,3); // prints &quot;method_missing(5, bob, 3 params)&quot;</div>
</div><!-- fragment --><p><code>method_missing</code> signature can be either 2 parameters or 3 parameters. If the signature contains two parameters it is treated as a property. If the property contains a function then additional parameters are passed to the contained function.</p>
<p>If both a 2 parameter and a 3 parameter signature match, the 3 parameter function always wins.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
Context</h2>
<ul>
<li><code>__LINE__</code> Current file line number</li>
<li><code>__FILE__</code> Full path of current file</li>
<li><code>__CLASS__</code> Name of current class</li>
<li><code>__FUNC__</code> Mame of current function</li>
</ul>
<h1><a class="anchor" id="autotoc_md52"></a>
Built In Functions</h1>
<h2><a class="anchor" id="autotoc_md53"></a>
Disabling Built-Ins</h2>
<p>When constructing a ChaiScript object, a vector of parameters can be passed in to disable or enable various built-in methods.</p>
<p>Current options:</p>
<div class="fragment"><div class="line">enum class Options</div>
<div class="line">{</div>
<div class="line">  Load_Modules,</div>
<div class="line">  No_Load_Modules,</div>
<div class="line">  External_Scripts,</div>
<div class="line">  No_External_Scripts</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md54"></a>
Evaluation</h2>
<div class="fragment"><div class="line">eval(&quot;4 + 5&quot;) // dynamically eval script string and returns value of last statement</div>
<div class="line">eval_file(&quot;filename&quot;) // evals file and returns value of last statement</div>
<div class="line">use(&quot;filename&quot;) // evals file exactly once and returns value of last statement</div>
<div class="line">                // if the file had already been &#39;used&#39; nothing happens and undefined is returned</div>
</div><!-- fragment --><p>Both <code>use</code> and <code>eval_file</code> search the 'usepaths' passed to the ChaiScript constructor</p>
<h2><a class="anchor" id="autotoc_md55"></a>
JSON</h2>
<ul>
<li><code>from_json</code> converts a JSON string into its strongly typed (map, vector, int, double, string) representations</li>
<li><code>to_json</code> converts a ChaiScript object (either a <code>Object</code> or one of map, vector, int, double, string) tree into its JSON string representation </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
